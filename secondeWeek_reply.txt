辩题：redux
      总体概述：由最顶层分发状态，让react组件被动的渲染（即数据推动页面的渲染）。监听事件，事件有权利回到所有状态顶层去影响状态
      关于为什么要用到redux：在react中有props和state，props是从父级向子组件传递数据的一个管道，state是组件内可以自行关系的状态。
但是一个应用里的子组件几乎不可能只向父组件索取数据而不返回数据。而react没有数据回溯的能力，它只具有数据的单向输出。如要返
回数据，需要通过回调函数（即父组件通过props给子组件传递一个函数。子组件想传数据的时候，只要调用父组件传进来的函数，把数据
当参数传进去并调用该函数，这样父组件就收到了子组件传来的数据），在一定程度上通过组件自治可以规避这个问题，但是当需要从一个
组件向另一个组件进行通讯时，react就显得力不从心了。并且当一个组件改变全局变量时，某个组件的状态需要共享，某个状态需要在任何
地方被拿到的时候react都会显得力不从心，需要一层一层的回调到顶级组件，然后再派发下去。这样就造成了系统的很大的耦合。
关于redux：为了更好的state管理，需要一个库来作为更专业的顶层state分发给所有react应用。与react作比较：回调函数等同于action
进行回调处理等同于reducer，而总状态等同于store。
       redux有三个使用原则：单一数据源（整个应用的state，存储在唯一一个object中，同时也只有一个用于存储的object），
状态是只读的（唯一能改变state的方法是触发action操作。action是用来描述正在发生的事件的一个对象），
通过纯函数修改state（对于同一个输入，必然有相同的输出，这就保证了数据的可控性，也就是reducer）
       action：是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑
reducer:是一个匹配函数，action发送的是全局的，所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻
辑处理，修改store中的状态，不想关就不对state做处理原样返回。
       store负责存储状态并可以被react api回调发布action
       其中react-redux提供一个provide和connect。provide是一个普通的组件，可以作为顶层app的分发点，他只需要store属性
它会把state分发给所有被connect的组件，不管它在哪里被嵌套了多少层。
       connect：它接受两个参数（数据绑定：manStateToProps和事件绑定：manDispatchToProps），再绑定一个参数（将要绑定的
组件本身。）
       mapStateToProps：构建好redux系统的时候，它会被自动初始化，但是react组件并不知道它的存在，因此需要分拣出你需要的redux
状态，所以需要绑定一个函数，它的参数是state
       manDispatchcToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数dispatch，通过redux的辅
助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单声明了。它是可选的，将action作为
props绑定到组件上，如果不传这个参数redux会把dispatch作为属性注入给组件，可以手动当做store.dispatch使用

