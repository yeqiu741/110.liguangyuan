辩题：
数据的扁平化：
第一点是关于redux：
	redux有三个使用原则：单一数据源（整个应用的state，存储在唯一一个object中，同时也只有一个用于存储的object），
	状态是只读的（唯一能改变state的方法是触发action操作。action是用来描述正在发生的事件的一个对象），
	通过纯函数修改state（对于同一个输入，必然有相同的输出，这就保证了数据的可控性，也就是reducer）
       	action：是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑
	reducer:是一个匹配函数，action发送的是全局的，所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻
	辑处理，修改store中的状态，不想关就不对state做处理原样返回。
       	store负责存储状态并可以被react api回调发布action
       	其中react-redux提供一个provide和connect。provide是一个普通的组件，可以作为顶层app的分发点，他只需要store属性
	它会把state分发给所有被connect的组件，不管它在哪里被嵌套了多少层。
       	connect：它接受两个参数（数据绑定：manStateToProps和事件绑定：manDispatchToProps），再绑定一个参数（将要绑定的
	组件本身。）
       	mapStateToProps：构建好redux系统的时候，它会被自动初始化，但是react组件并不知道它的存在，因此需要分拣出你需要的redux
	状态，所以需要绑定一个函数，它的参数是state
       manDispatchcToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数dispatch，通过redux的辅
	助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单声明了。它是可选的，将action作为
	props绑定到组件上，如果不传这个参数redux会把dispatch作为属性注入给组件，可以手动当做store.dispatch使用
	首先是：axios:是基于promise用于浏览器和node.js的http客户端。支持浏览器和node.js，能够拦截请求和响应
	问题：前几周做作业用的数据都是直接直接写在redux中的死数据，但是实际开发中不可能不跟服务器进行交互，除非给客户展示的是一个静态的
	不需要任何交互的页面。
第二点是获取服务器传过来的数据：
	axios有两种请求方式：post和get方式。post方式是采取加密传输使用data参数，添加到请求体（body)中的，而get方式是非加密运输，采用params、
	参数，添加到url的请求字符串中的。
	axios的模型：在axios体中首先要指定method即请求方式，然后是接口url，再者就是headersz主要是指定编码格式，axios默认是使用/json格式进行传输，
	在传输的过程中需要前后端保持一致否则将出现不可预估的错误。接下来是根据选取的请求方式选填data或者params参数。请求发送成功后，如果
	数据请求成功会到.then方法，next（dispatch）一个action，把请求来的数据发送给reducer。如果没有请求成功，则走.catch方法，同样next一个action
	通过打印可以在控制台看到数据是否请求成功。

第三点是中间件：1、中间件是处于dispatch和reducer之间
		 2、什么是依赖：第二步需要第一步的执行之后才能执行
		 3、中间件结构：export default middle=stroe=>next=>actions{}
		 4、可插拔
第四点是对获取的数据进行扁平化：
	关于扁平化：数据的扁平化就是将深层级的数据变成单层级数据，方便数据的调用与修改，维护。
	首先是在acton中return之后添加一句代码：normailzerFun:response=>{response.data.xxx, schemes.xxxx}
        作用是在中间件中执行action之后对获取成功的数据进行拦截，按照schemes里写的规则进行清洗过滤
	然后在reducer文件中创建唯一的一个entites文件，获取清洗出来的数据并进行处理。之所以创建一个唯一的entities文件是为了保证数据的共享与复用
	然后再创建一个相对应的文件，获取清洗出来的result
	最后是在容器组件里进行合并，并传给需要数据的组件
